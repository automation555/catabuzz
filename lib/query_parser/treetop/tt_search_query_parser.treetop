grammar CatabuzzTerminals
  rule time
    digit digit digit digit?
    {
      def value
        text_value.to_i
      end
    }
  end  

  rule day
    "TBA" / "tba" / "Tba" / "tBa" / "tbA" / "TBa" / "TbA" / "tBA" / [Mm] / [Tt] / [Ww] / [Rr] / [Ff] / [Ss]
  end

  rule digit
    [0-9]
  end

  rule s
  	[ \t\n\r]+
  end

  rule char
    (w / W)
  end

  rule w
    [a-z]
  end

  rule W
    [A-Z]
  end

end

 grammar CatabuzzSegmentClassifier
#   # include CatabuzzTerminals
#   
#   rule text
#     seq:(token)*
#   end
#   
#   rule token
#   end
 end
# 
# grammar TTSearchQuery
# # rule string
# #    '"' (!'"' . / '\"')* '"'
# # end
#   include CatabuzzTerminals
#   
#   rule search_query_root
#     query seq:(query)*  
#     {
#       def value
#         sum = seq.elements.inject(query.value) { |sum, el|
#             # sum + " " + el.query.value
#             sum.update(el.query.value)
#           }
#           
#         # sum.update({:leftovers => leftovers.text_value})
#       end
#     }
#   end
#   
#   rule leftovers
#     .*
#   end
#   
#   rule query
#     code / weekdays / department / name / timerange
#   end
#   
#   rule code
#     char+ digit+ char*
#     {
#       def value
#         {:code => text_value.upcase}
#       end
#     }
#   end
#   
#   rule weekdays
#     day+ !(!s .)
#     {
#       def value
#         {:days => text_value.upcase}
#       end
#     }
#   end
# 
#   rule department
#     W W+
#     {
#        def value
#        {:department_name => text_value}
#       end
#     }
#   end
#   
#   rule name
#     (char / digit / [-;.,:])+
#     {
#        def value
#        {:name => text_value}
#       end
#     }
#   end
#   
#   
#   rule timerange
#     left_timerange / fulltimerange / right_timerange
#   end
#   
#   rule left_timerange
#     "-" s* end_time:time
#       {
#           def value
#               e = end_time.value
#               {:end_time => "<= #{e}"}
#           end
#       }
#   end
#   
#   rule right_timerange
#     start_time:time s* "-" 
#       {
#           def value
#               s = start_time.value
#               {:start_time => ">= #{s}"}
#           end
#       }
#   end
#   
#   
#   rule fulltimerange
#       start_time:time s* "-" s* end_time:time 
#       {
#           def value
#               s = start_time.value
#               e = end_time.value
#               if e > s
#                 {:start_time => ">= #{s}", :end_time => "<= #{e}"}
#               else
#                 {}
#               end
#           end
#       }
#   end
#   
# 
# end
